# -*- coding: utf-8 -*-
"""ExpMRegLogMNIST_Iris.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rGObSNgZ6HtcRIM3yddFXcXSAWI4MIdo

# Implementação de um algoritmo para fornecer explicações minimais
# para modelos de regressão logística para problemas de classificação
# multiclasse (one-versus-rest ou softmax).

A implementação do
algoritmo deve ser genérica para lidar com problemas com um número
arbitrário de features e de classes. Para ajudar, você pode olhar os
colabs disponibilizados nos materiais de aula. Além disso, o algoritmo
para explicação minimal está nas anotações do professor, também
disponibilizadas nos materiais de aula. O aluno também pode usar ferramentas de geração de código livremente.

Para testar seu código, um dos testes deve ser em um modelo treinado no conjundo de dados IRIS. Um outro teste deverá ser realizado por cada aluno conforme a lista a seguir:

Gleilson: modelo treinado no conjunto de dados MNIST apenas com classes 2, 4 e 7.

A explicação de uma instância do MNIST deve pintar de vermelho os pixels irrelevantes e deixar o pixel original para os pixels da explicação minimal.
"""

!pip install z3-solver

from sklearn.datasets import fetch_openml
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score
from z3 import *
import matplotlib.pyplot as plt
from sklearn.datasets import load_iris
from PIL import Image

mnist = fetch_openml('mnist_784', version=1, cache=True, parser='auto')
X_iris, y_iris = load_iris(return_X_y=True, as_frame=True)

scaler = MinMaxScaler()
scaler.fit(mnist.data)
scaler.set_output(transform='pandas')
data_scaled = scaler.transform(mnist.data)

scaler.fit(X_iris)
scaler.set_output(transform='pandas')
X_iris = scaler.transform(X_iris)

X, y = mnist.data, mnist.target
y = y.astype(np.uint8)

classes_to_keep = [2, 4, 7]
mask = np.isin(y, classes_to_keep)
X_filtered = X[mask]
y_filtered = y[mask]

X_train, X_test, y_train, y_test = train_test_split(X_filtered, y_filtered, test_size=0.3, stratify=y_filtered)

X_train_iris, X_test_iris, y_train_iris, y_test_iris = train_test_split(X_iris, y_iris, test_size=0.3, stratify=y_iris)

logistic_regression_classifier = LogisticRegression(multi_class='multinomial', max_iter=200)
iris_class = LogisticRegression(multi_class='multinomial', max_iter=200)

logistic_regression_classifier.fit(X_train, y_train)
iris_class.fit(X_train_iris, y_train_iris)

predictions = logistic_regression_classifier.predict(X_test)
predictions_iris = iris_class.predict(X_test_iris)

predictions_iris

accuracy = accuracy_score(y_test, predictions)
accuracy_iris = accuracy_score(y_test_iris, predictions_iris)
print("Mnist accuracy:", accuracy)
print("Iris accuracy:", accuracy_iris)

def plot_mnist_image(image):
    plt.imshow(image.reshape(28, 28), cmap='binary')
    plt.axis('off')
    plt.show()

#global real_vars MNIST
real_vars = [Real('x_' + feature_name) for feature_name in X_filtered.columns]
domain_constraints_upper_bound = [x <= u for (x, u) in zip(real_vars, X_filtered.max())]
domain_constraints_lower_bound = [x >= l for (l, x) in zip(X_filtered.min(), real_vars)]
domain_constraints = domain_constraints_upper_bound + domain_constraints_lower_bound
logistic_reg1_term = logistic_regression_classifier.coef_[0] @ real_vars + logistic_regression_classifier.intercept_[0]
logistic_reg2_term = logistic_regression_classifier.coef_[1] @ real_vars + logistic_regression_classifier.intercept_[1]
logistic_reg3_term = logistic_regression_classifier.coef_[2] @ real_vars + logistic_regression_classifier.intercept_[2]

#global real_vars_iris
real_vars_iris = [Real('x_' + feature_name) for feature_name in X_iris.columns]
domain_constraints_upper_bound_iris = [x <= u for (x, u) in zip(real_vars_iris, X_iris.max())]
domain_constraints_lower_bound_iris = [x >= l for (l, x) in zip(X_iris.min(), real_vars_iris)]
domain_constraints_iris = domain_constraints_upper_bound_iris + domain_constraints_lower_bound_iris
logistic_reg1_term_iris = iris_class.coef_[0] @ real_vars_iris + iris_class.intercept_[0]
logistic_reg2_term_iris = iris_class.coef_[1] @ real_vars_iris + iris_class.intercept_[1]
logistic_reg3_term_iris = iris_class.coef_[2] @ real_vars_iris + iris_class.intercept_[2]

print(domain_constraints)
print(domain_constraints_iris)

def encontrar_pixels_irrelevantes(imagem, modelo, classe_original):
    """
    Encontra os pixels mais sensíveis à mudança na predição do modelo.

    Args:
        imagem: A imagem como um array NumPy (28x28).
        modelo: O modelo de regressão logística.
        classe_original: A classe original prevista pelo modelo para a imagem.

    Returns:
        Uma lista com os índices dos pixels mais sensíveis.
    """

    # Calcular a predição original
    original_prediction = modelo.predict_proba(imagem.reshape(1, -1))[0]

    # Armazenar as diferenças de probabilidade e os índices dos pixels
    diffs = []

    # Iterar por cada pixel
    for i in range(imagem.size):
        # Criar uma cópia da imagem
        imagem_modificada = imagem.copy()

        # Mudar o valor do pixel para 0 ou 1
        imagem_modificada[i] = 1 if imagem_modificada[i] == 0 else 0

        # Calcular a nova predição
        nova_predição = modelo.predict_proba(imagem_modificada.reshape(1, -1))[0]

        # Calcular a diferença de probabilidade
        diff = abs(nova_predição[classe_original] - original_prediction[classe_original])

        # Armazenar a diferença e o índice do pixel
        diffs.append((diff, i))

    # Ordenar os pixels pela diferença de probabilidade
    diffs.sort(reverse=True)

    # Retornar os índices dos pixels mais sensíveis
    return [pixel_index for diff, pixel_index in diffs]

def minimalExplanation(I, D, P):
    E = [x == u for x, u in zip(real_vars, I)]
    solver = Solver()
    red_pixels = []
    for i in range(len(E) - 1, -1, -1):
        solver.reset()
        E_temp = E.copy()
        del E_temp[i]

        solver.add(E_temp)
        solver.add(D)
        solver.add(Not(P))
        if solver.check() != sat:
            E = E_temp.copy()
            red_pixels.append(i)


    return E, red_pixels

def minimalExplanationWithReturnInput(I, D, P):
    E = [x == u for x, u in zip(real_vars_iris, I)]
    print("Entrada original:", E)
    solver = Solver()
    for i in range(len(E) - 1, -1, -1):
        solver.reset()
        E_temp = E.copy()
        del E_temp[i]

        solver.add(E_temp)
        solver.add(D)
        solver.add(Not(P))
        if solver.check() != sat:
            E = E_temp.copy()

    return E

def pintar_pixels(imagem, deleted_pixels):
    if not isinstance(imagem, np.ndarray):
        imagem = np.array(imagem)

    if imagem.ndim == 2:
        imagem = imagem.flatten()

    imagem = imagem.astype(np.uint8)

    imagem = imagem.reshape(28, 28)

    imagem_rgb = Image.fromarray(imagem).convert("RGB")
    pixels = imagem_rgb.load()

    vermelho = (255, 0, 0)

    for index in deleted_pixels:
        x = index % 28
        y = index // 28
        pixels[x, y] = vermelho

    return imagem_rgb

for i in range(10):
    if(predictions_iris[i] == 0):
        formula = And(logistic_reg1_term_iris > logistic_reg2_term_iris, logistic_reg1_term_iris > logistic_reg3_term_iris)

    elif(predictions_iris[i] == 1):
        formula = And(logistic_reg2_term_iris > logistic_reg1_term_iris, logistic_reg2_term_iris > logistic_reg3_term_iris)

    else:
        formula = And(logistic_reg3_term_iris > logistic_reg1_term_iris, logistic_reg3_term_iris > logistic_reg2_term_iris)

    minexp = minimalExplanationWithReturnInput(X_test_iris.iloc[i], domain_constraints_iris, formula)
    print("\nExplicação minimal para a entrada {}\n".format(i), minexp)

for i in range(4):
    if(predictions[i] == 2):
        formula = And(logistic_reg1_term > logistic_reg2_term, logistic_reg1_term > logistic_reg3_term)

    elif(predictions[i] == 4):
        formula = And(logistic_reg2_term > logistic_reg1_term, logistic_reg2_term > logistic_reg3_term)

    else:
        formula = And(logistic_reg3_term > logistic_reg1_term, logistic_reg3_term > logistic_reg2_term)

    img, red_pixel = minimalExplanation(X_test.iloc[i], domain_constraints, formula)

    img_rgb = pintar_pixels(X_test.iloc[i], red_pixel)
    # plot_mnist_image(np.array(X_test.iloc[i]))
    fig, axs = plt.subplots(1, 2, figsize=(10, 5))

    axs[0].imshow(np.array(X_test.iloc[i]).reshape(28, 28), cmap='gray')
    axs[0].set_title('Imagem Original')
    axs[0].axis('off')


    axs[1].imshow(img_rgb)
    axs[1].set_title('Imagem Modificada')
    axs[1].axis('off')

    plt.show()